{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scaffolding de Arquitectura Limpia en Python para Microservicios en la Nube","text":"<p>Bienvenido al Scaffolding de Arquitectura Limpia en Python, un proyecto dise\u00f1ado para proporcionar una base s\u00f3lida y estructurada en el desarrollo de microservicios escalables y mantenibles, aplicando los principios de la Arquitectura Limpia propuestos por Robert C. Martin.</p>"},{"location":"#indice","title":"\u00cdndice","text":"<ul> <li>Introducci\u00f3n</li> <li>Estructura del Proyecto</li> <li>Capas</li> <li>Dominio</li> <li>Aplicaci\u00f3n</li> <li>Infraestructura</li> <li>Presentaci\u00f3n</li> <li>Configuraci\u00f3n del Entorno</li> <li>Pruebas</li> <li>Integraci\u00f3n Continua y Despliegue Continuo (CI/CD)</li> <li>Despliegue en la Nube</li> <li>Conclusi\u00f3n</li> </ul>"},{"location":"#descripcion-general","title":"Descripci\u00f3n General","text":"<p>Este proyecto tiene como objetivo facilitar el desarrollo de microservicios en Python mediante una estructura clara y modular que siga los principios de la Arquitectura Limpia. Al utilizar este scaffolding, los desarrolladores pueden centrarse en la l\u00f3gica de negocio sin preocuparse por la configuraci\u00f3n inicial de la arquitectura, promoviendo as\u00ed pr\u00e1cticas de c\u00f3digo limpio y sostenible.</p>"},{"location":"#capas","title":"Capas","text":"<p>La arquitectura se divide en cuatro capas principales, cada una con responsabilidades espec\u00edficas y bien definidas:</p> <ul> <li>Dominio: Contiene las entidades y reglas de negocio fundamentales, independientes de tecnolog\u00edas y frameworks externos. Ver+</li> <li>Aplicaci\u00f3n: Orquesta los casos de uso y coordina la interacci\u00f3n entre el dominio y la infraestructura. Ver+</li> <li>Infraestructura: Provee implementaciones concretas para las interfaces definidas en la capa de aplicaci\u00f3n, manejando detalles t\u00e9cnicos como bases de datos, servicios externos y sistemas de mensajer\u00eda. Ver+</li> <li>Presentaci\u00f3n: Gestiona la interacci\u00f3n con el usuario o cliente, ya sea a trav\u00e9s de APIs RESTful, interfaces gr\u00e1ficas u otros medios de comunicaci\u00f3n. Ver+</li> </ul>"},{"location":"#objetivos-del-proyecto","title":"Objetivos del Proyecto","text":"<ul> <li>Promover la Separaci\u00f3n de Responsabilidades: Facilitar un desarrollo modular donde cada capa tiene un prop\u00f3sito espec\u00edfico.</li> <li>Facilitar la Mantenibilidad: Al aislar las dependencias y reducir el acoplamiento, se simplifica el mantenimiento y la evoluci\u00f3n del software.</li> <li>Mejorar la Escalabilidad: Permitir que el sistema crezca y se adapte a nuevas necesidades sin comprometer su integridad estructural.</li> <li>Fomentar Buenas Pr\u00e1cticas: Aplicar principios s\u00f3lidos de ingenier\u00eda de software, como el Principio de Inversi\u00f3n de Dependencias y el Principio de Responsabilidad \u00danica.</li> </ul>"},{"location":"#como-empezar","title":"C\u00f3mo Empezar","text":"<p>Para comenzar a utilizar este scaffolding y entender c\u00f3mo se estructura el proyecto, te recomendamos seguir estos pasos:</p> <ol> <li>Leer la Introducci\u00f3n: Proporciona una visi\u00f3n general de los conceptos y motivaciones detr\u00e1s de la Arquitectura Limpia.</li> <li>Revisar la Estructura del Proyecto: Detalla c\u00f3mo se organizan los archivos y directorios.</li> <li>Explorar las Capas: Comprende el prop\u00f3sito de cada capa y c\u00f3mo interact\u00faan entre s\u00ed.</li> <li>Configurar el Entorno: Sigue las instrucciones en Configuraci\u00f3n del Entorno para preparar tu ambiente de desarrollo.</li> <li>Ejecutar Pruebas: Aprende c\u00f3mo implementar y ejecutar pruebas consultando la secci\u00f3n Pruebas.</li> </ol>"},{"location":"#contribuciones","title":"Contribuciones","text":"<p>Este proyecto es de c\u00f3digo abierto y agradecemos las contribuciones de la comunidad. Si deseas colaborar, por favor revisa las pautas en <code>CONTRIBUTING.md</code> y env\u00eda tus pull requests o reporta issues en el repositorio oficial.</p>"},{"location":"cicd/","title":"Integraci\u00f3n Continua y Despliegue Continuo (CI/CD)","text":"<p>La implementaci\u00f3n de una estrategia robusta de Integraci\u00f3n Continua (CI) y Despliegue Continuo (CD) es esencial para garantizar la calidad, confiabilidad y eficiencia en el ciclo de vida del desarrollo de software. Este proyecto utiliza Azure DevOps como plataforma principal para orquestar las canalizaciones de CI/CD, y considera despliegues tanto en Azure como en AWS para aprovechar las fortalezas de ambas nubes.</p>"},{"location":"cicd/#configuracion-de-azure-devops","title":"Configuraci\u00f3n de Azure DevOps","text":""},{"location":"cicd/#1-creacion-del-proyecto-en-azure-devops","title":"1. Creaci\u00f3n del Proyecto en Azure DevOps","text":"<ul> <li>Acceda al portal de Azure DevOps y autent\u00edquese con sus credenciales.</li> <li>Cree una nueva organizaci\u00f3n o utilice una existente.</li> <li>Genere un nuevo proyecto seleccionando \"Crear proyecto\" y proporcionando un nombre y descripci\u00f3n adecuados.</li> </ul>"},{"location":"cicd/#2-repositorio-de-codigo-fuente","title":"2. Repositorio de C\u00f3digo Fuente","text":"<ul> <li>Importe el c\u00f3digo fuente del proyecto al repositorio Git integrado en Azure DevOps o enlace un repositorio externo, como GitHub.</li> <li>Verifique que la estructura del proyecto y todos los archivos necesarios (por ejemplo, <code>Dockerfile</code>, <code>docker-compose.yml</code>, <code>requirements.txt</code>, etc.) est\u00e9n presentes en el repositorio.</li> </ul>"},{"location":"cicd/#configuracion-de-la-canalizacion-de-integracion-continua-ci","title":"Configuraci\u00f3n de la Canalizaci\u00f3n de Integraci\u00f3n Continua (CI)","text":"<p>La canalizaci\u00f3n de CI automatiza la construcci\u00f3n y las pruebas del c\u00f3digo cada vez que se produce un cambio en el repositorio.</p>"},{"location":"cicd/#1-creacion-de-la-canalizacion","title":"1. Creaci\u00f3n de la Canalizaci\u00f3n","text":"<ul> <li>Navegue a la secci\u00f3n \"Pipelines\" en Azure DevOps y seleccione \"Crear Pipeline\".</li> <li>Seleccione el repositorio que contiene el c\u00f3digo fuente.</li> <li>Opte por \"Inicio r\u00e1pido\" para utilizar una plantilla b\u00e1sica o elija \"Archivo YAML\" para definir la canalizaci\u00f3n mediante un archivo <code>azure-pipelines.yml</code>.</li> </ul>"},{"location":"cicd/#2-definicion-del-archivo-azure-pipelinesyml","title":"2. Definici\u00f3n del Archivo <code>azure-pipelines.yml</code>","text":"<p>Cree un archivo llamado <code>azure-pipelines.yml</code> en la ra\u00edz del proyecto con el siguiente contenido:</p> <pre><code># azure-pipelines.yml\ntrigger:\n  branches:\n    include:\n      - main\n      - develop\n\npool:\n  vmImage: 'ubuntu-latest'\n\nvariables:\n  PYTHON_VERSION: '3.9'\n\nsteps:\n  - task: UsePythonVersion@0\n    inputs:\n      versionSpec: '$(PYTHON_VERSION)'\n    displayName: 'Configurar Python $(PYTHON_VERSION)'\n\n  - script: |\n      python -m pip install --upgrade pip\n      pip install -r requirements.txt\n    displayName: 'Instalar dependencias'\n\n  - script: |\n      pytest tests/ --junitxml=test-results.xml\n    displayName: 'Ejecutar pruebas'\n\n  - task: PublishTestResults@2\n    inputs:\n      testResultsFormat: 'JUnit'\n      testResultsFiles: '**/test-results.xml'\n    displayName: 'Publicar resultados de pruebas'\n\n  - task: PublishBuildArtifacts@1\n    inputs:\n      pathToPublish: '$(System.DefaultWorkingDirectory)'\n      artifactName: 'drop'\n    displayName: 'Publicar artefactos de compilaci\u00f3n'\n</code></pre>"},{"location":"cicd/#explicacion-de-la-canalizacion","title":"Explicaci\u00f3n de la Canalizaci\u00f3n","text":"<ul> <li>trigger: Configura la canalizaci\u00f3n para que se ejecute en las ramas especificadas (main y develop).</li> <li>pool: Especifica el agente de compilaci\u00f3n a utilizar (ubuntu-latest).</li> <li>variables: Define variables globales, como la versi\u00f3n de Python.</li> <li>steps: Lista de tareas a ejecutar:<ul> <li>UsePythonVersion: Configura la versi\u00f3n de Python en el agente.</li> <li>Instalar dependencias: Actualiza pip e instala las dependencias del proyecto.</li> <li>Ejecutar pruebas: Ejecuta las pruebas utilizando pytest y genera un archivo de resultados en formato JUnit.</li> <li>Publicar resultados de pruebas: Publica los resultados para que puedan ser visualizados en Azure DevOps.</li> <li>Publicar artefactos de compilaci\u00f3n: Guarda los artefactos generados durante la compilaci\u00f3n para su uso posterior en la canalizaci\u00f3n de CD.</li> </ul> </li> </ul>"},{"location":"cicd/#3-configuracion-de-variables-de-entorno","title":"3. Configuraci\u00f3n de Variables de Entorno","text":"<p>En la secci\u00f3n de variables de la canalizaci\u00f3n, configure las variables necesarias, como credenciales o configuraciones espec\u00edficas del entorno. Utilice variables secretas para manejar informaci\u00f3n sensible, asegur\u00e1ndose de que est\u00e9n protegidas y no se expongan en los logs.</p>"},{"location":"cicd/#configuracion-de-la-canalizacion-de-despliegue-continuo-cd","title":"Configuraci\u00f3n de la Canalizaci\u00f3n de Despliegue Continuo (CD)","text":"<p>La canalizaci\u00f3n de CD automatiza el proceso de despliegue de la aplicaci\u00f3n a los entornos correspondientes (desarrollo, pruebas, producci\u00f3n).</p>"},{"location":"cicd/#1-creacion-de-una-release-pipeline","title":"1. Creaci\u00f3n de una Release Pipeline","text":"<p>Navegue a la secci\u00f3n \"Releases\" en Azure DevOps y seleccione \"Nueva canalizaci\u00f3n\". Elija \"Empty Job\" para comenzar desde cero o seleccione una plantilla seg\u00fan sus necesidades.</p>"},{"location":"cicd/#2-definicion-de-las-etapas-de-despliegue","title":"2. Definici\u00f3n de las Etapas de Despliegue","text":"<ul> <li>Desarrollo: Primera etapa donde se despliega la aplicaci\u00f3n en un entorno de desarrollo para pruebas iniciales.</li> <li>Pruebas: Etapa donde se realizan pruebas m\u00e1s exhaustivas, incluyendo pruebas de integraci\u00f3n y aceptaci\u00f3n.</li> <li>Producci\u00f3n: Etapa final donde la aplicaci\u00f3n se despliega al entorno de producci\u00f3n.</li> </ul>"},{"location":"cicd/#3-configuracion-de-tareas-de-despliegue","title":"3. Configuraci\u00f3n de Tareas de Despliegue","text":"<p>En esta secci\u00f3n se abordar\u00e1 la configuraci\u00f3n de las tareas de despliegue para ambos entornos en la nube: Azure y AWS.</p>"},{"location":"cicd/#despliegue-en-azure","title":"Despliegue en Azure","text":"<p>Para desplegar la aplicaci\u00f3n en Azure, se utilizar\u00e1n servicios como Azure Container Instances (ACI) o Azure Kubernetes Service (AKS), dependiendo de las necesidades.</p>"},{"location":"cicd/#ejemplo-de-tarea-de-despliegue-en-azure","title":"Ejemplo de Tarea de Despliegue en Azure","text":""},{"location":"cicd/#4-configuracion-de-gates-y-aprobaciones","title":"4. Configuraci\u00f3n de Gates y Aprobaciones","text":"<p>Establezca gates y aprobaciones manuales entre las etapas para controlar el flujo de despliegue. Configure notificaciones para informar a los equipos relevantes sobre el progreso y estado de los despliegues. <pre><code>- task: AzureCLI@2\n  inputs:\n    azureSubscription: 'Conexi\u00f3n a Azure'\n    scriptType: 'bash'\n    scriptLocation: 'inlineScript'\n    inlineScript: |\n      # Configuraci\u00f3n de variables\n      IMAGE_NAME=your_microservice\n      IMAGE_TAG=$(Build.BuildId)\n      ACR_NAME=youracrname\n      RESOURCE_GROUP=your-resource-group\n      CONTAINER_GROUP=your-container-group\n\n      # Inicio de sesi\u00f3n en ACR\n      az acr login --name $ACR_NAME\n\n      # Construcci\u00f3n y etiquetado de la imagen\n      docker build -t $ACR_NAME.azurecr.io/$IMAGE_NAME:$IMAGE_TAG .\n\n      # Env\u00edo de la imagen a ACR\n      docker push $ACR_NAME.azurecr.io/$IMAGE_NAME:$IMAGE_TAG\n\n      # Despliegue en ACI\n      az container create \\\n        --resource-group $RESOURCE_GROUP \\\n        --name $CONTAINER_GROUP \\\n        --image $ACR_NAME.azurecr.io/$IMAGE_NAME:$IMAGE_TAG \\\n        --registry-login-server $ACR_NAME.azurecr.io \\\n        --registry-username $(ACR_USERNAME) \\\n        --registry-password $(ACR_PASSWORD) \\\n        --dns-name-label your-dns-label \\\n        --ports 8080\n  displayName: 'Desplegar en Azure Container Instances'\n</code></pre></p>"},{"location":"cicd/#despliegue-en-aws","title":"Despliegue en AWS","text":"<p>Para el despliegue en AWS, se pueden utilizar servicios como Amazon Elastic Container Service (ECS) o Amazon Elastic Kubernetes Service (EKS).</p>"},{"location":"cicd/#configuracion-de-credenciales-aws","title":"Configuraci\u00f3n de Credenciales AWS","text":"<p>Antes de ejecutar tareas en AWS, es necesario configurar las credenciales de acceso. Esto se puede hacer mediante variables de entorno o utilizando el servicio de Azure Key Vault para almacenar secretos.</p>"},{"location":"cicd/#ejemplo-de-tarea-de-despliegue-en-aws","title":"Ejemplo de Tarea de Despliegue en AWS","text":"<pre><code>- task: AWSCLI@1\n  inputs:\n    awsCredentials: 'Conexi\u00f3n a AWS'\n    awsRegionName: 'us-east-1'\n    scriptType: 'inline'\n    inlineScript: |\n      # Configuraci\u00f3n de variables\n      IMAGE_NAME=your_microservice\n      IMAGE_TAG=$(Build.BuildId)\n      AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)\n      ECR_REPO_NAME=your-ecr-repo\n\n      # Inicio de sesi\u00f3n en ECR\n      aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com\n\n      # Construcci\u00f3n y etiquetado de la imagen\n      docker build -t $IMAGE_NAME .\n\n      # Etiquetado de la imagen para ECR\n      docker tag $IMAGE_NAME:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO_NAME:$IMAGE_TAG\n\n      # Env\u00edo de la imagen a ECR\n      docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com/$ECR_REPO_NAME:$IMAGE_TAG\n\n      # Despliegue en ECS o EKS (se requiere configuraci\u00f3n adicional)\n      # Por ejemplo, actualizar una tarea de ECS con la nueva imagen\n  displayName: 'Desplegar en AWS Elastic Container Service'\n</code></pre>"},{"location":"cicd/#integracion-con-azure-key-vault","title":"Integraci\u00f3n con Azure Key Vault","text":""},{"location":"cicd/#integracion-con-azure-key-vault_1","title":"Integraci\u00f3n con Azure Key Vault","text":"<p>Para manejar de forma segura las credenciales y secretos necesarios durante el proceso de despliegue, se integra Azure Key Vault en las canalizaciones.</p> <p>Configuraci\u00f3n de Azure Key Vault - Cree un Azure Key Vault en su suscripci\u00f3n de Azure. - Agregue los secretos necesarios, como contrase\u00f1as, claves de API y otras credenciales sensibles. - Configure las pol\u00edticas de acceso para permitir que Azure DevOps Pipeline acceda al Key Vault.</p>"},{"location":"cicd/#uso-en-la-canalizacion","title":"Uso en la Canalizaci\u00f3n","text":"<p>Agregue una tarea en el azure-pipelines.yml para obtener los secretos del Key Vault:</p> <p><pre><code>- task: AzureKeyVault@2\n  inputs:\n    azureSubscription: 'Conexi\u00f3n a Azure'\n    KeyVaultName: 'your-key-vault-name'\n    SecretsFilter: '*'\n    RunAsPreJob: true\n  displayName: 'Descargar secretos desde Azure Key Vault'\n</code></pre> Con esta configuraci\u00f3n, los secretos estar\u00e1n disponibles como variables en la canalizaci\u00f3n y pueden ser utilizados en los scripts de despliegue.</p>"},{"location":"cicd/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ul> <li>Versionado Sem\u00e1ntico: Utilice un esquema de versionado consistente para las builds y despliegues.</li> <li>Principio de Menor Privilegio: Configure los permisos de acceso de las canalizaciones y servicios con el m\u00ednimo necesario.</li> <li>Validaci\u00f3n en Pull Requests: Configure pol\u00edticas de rama que requieran la aprobaci\u00f3n y el paso de las pruebas antes de fusionar cambios.</li> <li>Despliegue Azul-Verde o Canary: Considere estrategias avanzadas de despliegue para minimizar el impacto en producci\u00f3n.</li> <li>Seguridad de Credenciales: Nunca almacene credenciales sensibles en texto plano o en el repositorio de c\u00f3digo. Utilice servicios como Azure Key Vault o AWS Secrets Manager.</li> <li>Automatizaci\u00f3n Completa: Busque que el proceso de CI/CD sea completamente automatizado, reduciendo la intervenci\u00f3n manual y minimizando errores.</li> <li>Monitoreo y Alertas: Integre servicios de monitoreo como Azure Monitor o AWS CloudWatch para supervisar el rendimiento y estado de la aplicaci\u00f3n despu\u00e9s del despliegue.</li> <li>Despliegue Multinube: Al considerar despliegues en Azure y AWS, aseg\u00farese de que su aplicaci\u00f3n y procesos sean compatibles con ambos entornos, adoptando pr\u00e1cticas de infraestructura como c\u00f3digo cuando sea posible.</li> <li>Infraestructura como C\u00f3digo: Utilice herramientas como Terraform o Azure Resource Manager (ARM) Templates para definir y gestionar la infraestructura de forma declarativa.</li> </ul>"},{"location":"cicd/#recursos-adicionales","title":"Recursos Adicionales","text":"<ul> <li>Documentaci\u00f3n de Azure DevOps</li> <li>Pr\u00e1cticas recomendadas para CI/CD en Azure</li> <li>Integraci\u00f3n de Azure Key Vault con Azure DevOps</li> <li>Despliegue de Contenedores en AWS</li> </ul>"},{"location":"conclusion/","title":"Conclusi\u00f3n","text":"<p>La implementaci\u00f3n de una Arquitectura Limpia en el desarrollo de microservicios con Python proporciona una base s\u00f3lida para construir sistemas robustos, escalables y mantenibles. A lo largo de este proyecto, hemos explorado los principios fundamentales de esta arquitectura y c\u00f3mo aplicarlos de manera efectiva en un entorno de desarrollo moderno.</p> <p>Al separar claramente las responsabilidades en capas bien definidas de Dominio, Aplicaci\u00f3n, Infraestructura y Presentaci\u00f3n hemos logrado:</p> <ul> <li>Facilitar la Mantenibilidad: Al aislar la l\u00f3gica de negocio de los detalles de implementaci\u00f3n, el c\u00f3digo es m\u00e1s f\u00e1cil de entender, modificar y extender.</li> <li>Mejorar la Escalabilidad: La modularidad permite a\u00f1adir nuevas funcionalidades y servicios sin afectar el n\u00facleo de la aplicaci\u00f3n.</li> <li>Aumentar la Testabilidad: La independencia de componentes facilita la implementaci\u00f3n de pruebas unitarias y de integraci\u00f3n, mejorando la calidad del software.</li> <li>Promover la Flexibilidad Tecnol\u00f3gica: La abstracci\u00f3n de interfaces permite cambiar o actualizar tecnolog\u00edas subyacentes sin impactar las capas superiores.</li> </ul> <p>Adem\u00e1s, la integraci\u00f3n de pr\u00e1cticas modernas como Integraci\u00f3n Continua y Despliegue Continuo (CI/CD), junto con el despliegue automatizado en la nube mediante AWS CloudFormation, refuerza la eficiencia y confiabilidad del ciclo de vida del desarrollo de software.</p> <p>Este scaffolding no solo sirve como punto de partida para proyectos actuales, sino que tambi\u00e9n establece un est\u00e1ndar de buenas pr\u00e1cticas que pueden ser adoptadas y adaptadas en futuros desarrollos. Al seguir los principios y estructuras presentados, los equipos de desarrollo pueden abordar desaf\u00edos complejos con mayor confianza y eficacia.</p>"},{"location":"conclusion/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<ul> <li>Profundizar en las Mejores Pr\u00e1cticas: Continuar explorando patrones de dise\u00f1o y principios SOLID para enriquecer a\u00fan m\u00e1s la calidad del c\u00f3digo.</li> <li>Automatizaci\u00f3n Avanzada: Implementar pruebas automatizadas m\u00e1s complejas, como pruebas de carga y rendimiento, y considerar estrategias de despliegue azul-verde o canario.</li> <li>Monitoreo y Observabilidad: Integrar soluciones de monitoreo y logging avanzadas para obtener visibilidad en tiempo real del comportamiento de la aplicaci\u00f3n en producci\u00f3n.</li> <li>Seguridad: Fortalecer la seguridad en todas las capas, incluyendo pr\u00e1cticas como el an\u00e1lisis de vulnerabilidades y la gesti\u00f3n de secretos m\u00e1s robusta.</li> </ul>"},{"location":"configuracion/","title":"Configuraci\u00f3n del Entorno","text":"<p>Para garantizar un entorno de desarrollo consistente y facilitar la implementaci\u00f3n y despliegue del microservicio, es esencial configurar adecuadamente el entorno. Esta secci\u00f3n proporciona instrucciones detalladas para preparar el entorno de desarrollo, incluyendo la instalaci\u00f3n de dependencias, configuraci\u00f3n de variables de entorno y uso de contenedores.</p>"},{"location":"configuracion/#requisitos-previos","title":"Requisitos Previos","text":"<ul> <li>Python 3.9 o superior: Aseg\u00farese de tener instalada la versi\u00f3n adecuada de Python.</li> <li>Pip: El gestor de paquetes de Python para instalar las dependencias.</li> <li>Virtualenv (opcional pero recomendado): Para crear un entorno virtual aislado.</li> <li>Docker (opcional pero recomendado): Para facilitar el despliegue y ejecuci\u00f3n en contenedores.</li> </ul>"},{"location":"configuracion/#instalacion-de-dependencias","title":"Instalaci\u00f3n de Dependencias","text":"<p>Es recomendable utilizar un entorno virtual para aislar las dependencias del proyecto.</p>"},{"location":"configuracion/#creacion-de-un-entorno-virtual","title":"Creaci\u00f3n de un Entorno Virtual","text":""},{"location":"configuracion/#venv","title":"venv","text":"<pre><code># Crear un entorno virtual\npython -m venv venv\n\n# Activar el entorno virtual (Unix/Mac)\nsource venv/bin/activate\n\n# Activar el entorno virtual (Windows)\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"configuracion/#virtualenv","title":"virtualenv","text":"<pre><code># Instalar virtualenv si no lo tiene instalado\npip install virtualenv\n\n# Crear un entorno virtual\nvirtualenv venv\n\n# Activar el entorno virtual (Unix/Mac)\nsource venv/bin/activate\n\n# Activar el entorno virtual (Windows)\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"configuracion/#instalacion-de-paquetes","title":"Instalaci\u00f3n de Paquetes","text":"<p>Con el entorno virtual activado, instale las dependencias listadas en requirements.txt:</p> <pre><code>pip install -r requirements.txt\n</code></pre>"},{"location":"configuracion/#configuracion-de-variables-de-entorno","title":"Configuraci\u00f3n de Variables de Entorno","text":"<p>Las variables de entorno permiten configurar par\u00e1metros sin alterar el c\u00f3digo fuente. Cree un archivo .env en la ra\u00edz del proyecto para definir variables sensibles o espec\u00edficas del entorno.</p>"},{"location":"configuracion/#ejemplo-de-archivo-env","title":"Ejemplo de Archivo .env","text":"<pre><code># Configuraci\u00f3n de la base de datos\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=usuario\nDB_PASSWORD=contrase\u00f1a\nDB_NAME=nombre_base_datos\n\n# Configuraci\u00f3n del entorno\nENVIRONMENT=development\n\n# Configuraci\u00f3n de logging\nLOG_LEVEL=DEBUG\n</code></pre> <p>Aseg\u00farese de que el archivo .env est\u00e9 incluido en el archivo .gitignore para evitar subir informaci\u00f3n sensible al repositorio.</p>"},{"location":"configuracion/#configuracion-de-logging","title":"Configuraci\u00f3n de Logging","text":"<p>El archivo config/logging.conf contiene la configuraci\u00f3n para el sistema de logging de la aplicaci\u00f3n. Ajuste los par\u00e1metros seg\u00fan las necesidades de monitoreo y depuraci\u00f3n.</p>"},{"location":"configuracion/#estructura-de-loggingconf","title":"Estructura de logging.conf","text":"<pre><code>[loggers]\nkeys=root,app\n\n[handlers]\nkeys=consoleHandler,fileHandler\n\n[formatters]\nkeys=simpleFormatter\n\n[logger_root]\nlevel=WARNING\nhandlers=consoleHandler\n\n[logger_app]\nlevel=DEBUG\nhandlers=consoleHandler,fileHandler\nqualname=app\npropagate=0\n\n[handler_consoleHandler]\nclass=StreamHandler\nlevel=DEBUG\nformatter=simpleFormatter\nargs=(sys.stdout,)\n\n[handler_fileHandler]\nclass=FileHandler\nlevel=INFO\nformatter=simpleFormatter\nargs=('logs/app.log', 'a')\n\n[formatter_simpleFormatter]\nformat=%(asctime)s - %(name)s - %(levelname)s - %(message)s\ndatefmt=\n</code></pre>"},{"location":"configuracion/#uso-de-docker","title":"Uso de Docker","text":"<p>Para facilitar la ejecuci\u00f3n y despliegue de la aplicaci\u00f3n en diferentes entornos, puede utilizar Docker para contenerizar el microservicio.</p>"},{"location":"configuracion/#construccion-de-la-imagen-docker","title":"Construcci\u00f3n de la Imagen Docker","text":"<pre><code>docker build -t your_microservice:latest .\n</code></pre>"},{"location":"configuracion/#ejecucion-del-contenedor","title":"Ejecuci\u00f3n del Contenedor","text":"<pre><code>docker run -d -p 8080:8080 --env-file .env your_microservice:latest\n</code></pre>"},{"location":"configuracion/#uso-de-docker-compose","title":"Uso de Docker Compose","text":"<p>Si su aplicaci\u00f3n depende de otros servicios (por ejemplo, una base de datos), puede utilizar docker-compose.yml para orquestar m\u00faltiples contenedores.yaml</p> <pre><code>version: '3.8'\nservices:\n  app:\n    build: .\n    ports:\n      - \"8080:8080\"\n    env_file:\n      - .env\n    depends_on:\n      - db\n  db:\n    image: postgres:13\n    environment:\n      - POSTGRES_USER=${DB_USER}\n      - POSTGRES_PASSWORD=${DB_PASSWORD}\n      - POSTGRES_DB=${DB_NAME}\n    ports:\n      - \"5432:5432\"\n</code></pre> <p>Para iniciar los servicios:</p> <pre><code>docker-compose up -d\n</code></pre>"},{"location":"configuracion/#configuracion-del-archivo-settingspy","title":"Configuraci\u00f3n del Archivo settings.py","text":"<p>El archivo config/settings.py centraliza la configuraci\u00f3n de la aplicaci\u00f3n, leyendo variables de entorno y proporcionando valores predeterminados cuando sea necesario.</p>"},{"location":"configuracion/#ejemplo-de-settingspy","title":"Ejemplo de settings.py","text":"<pre><code>import os\nfrom dotenv import load_dotenv\n\n# Cargar variables de entorno desde .env\nload_dotenv()\n\nclass Settings:\n    # Configuraci\u00f3n de la base de datos\n    DB_HOST = os.getenv('DB_HOST', 'localhost')\n    DB_PORT = int(os.getenv('DB_PORT', 5432))\n    DB_USER = os.getenv('DB_USER', 'user')\n    DB_PASSWORD = os.getenv('DB_PASSWORD', 'password')\n    DB_NAME = os.getenv('DB_NAME', 'database')\n\n    # Configuraci\u00f3n del entorno\n    ENVIRONMENT = os.getenv('ENVIRONMENT', 'development')\n\n    # Configuraci\u00f3n de logging\n    LOG_LEVEL = os.getenv('LOG_LEVEL', 'INFO')\n\nsettings = Settings()\n</code></pre>"},{"location":"configuracion/#recomendaciones-adicionales","title":"Recomendaciones Adicionales","text":"<ul> <li>Mantenga las Dependencias Actualizadas: Revise peri\u00f3dicamente el archivo requirements.txt y actualice los paquetes para incluir parches de seguridad y mejoras.</li> <li>Seguridad de Variables Sensibles: No comparta archivos que contengan informaci\u00f3n sensible y utilice herramientas como Vault o servicios de gesti\u00f3n de secretos para entornos de producci\u00f3n.</li> <li>Consistencia en Entornos: Use herramientas de automatizaci\u00f3n y contenedores para asegurar que los entornos de desarrollo, pruebas y producci\u00f3n sean lo m\u00e1s similares posible.</li> </ul>"},{"location":"despliegue/","title":"Despliegue en la Nube","text":"<p>El despliegue en la nube es una etapa cr\u00edtica en el ciclo de vida del desarrollo de software, ya que permite que la aplicaci\u00f3n est\u00e9 disponible y accesible para los usuarios finales. En este proyecto, se utilizar\u00e1 Amazon Web Services (AWS) como plataforma de nube, aprovechando sus servicios robustos y escalables. La implementaci\u00f3n se realizar\u00e1 mediante AWS CloudFormation, una herramienta que permite modelar y aprovisionar recursos de AWS de manera automatizada y reproducible.</p>"},{"location":"despliegue/#aws-cloudformation","title":"AWS CloudFormation","text":"<p>AWS CloudFormation es un servicio que facilita la gesti\u00f3n de infraestructura como c\u00f3digo (IaC), permitiendo describir los recursos de AWS necesarios mediante archivos de plantilla en formato YAML o JSON. Esto asegura consistencia en los despliegues y simplifica la gesti\u00f3n de cambios en la infraestructura.</p>"},{"location":"despliegue/#arquitectura-de-despliegue","title":"Arquitectura de Despliegue","text":"<p>La arquitectura de despliegue propuesta incluye los siguientes componentes:</p> <ul> <li>Amazon Elastic Container Service (ECS): Servicio de orquestaci\u00f3n de contenedores para ejecutar la aplicaci\u00f3n Dockerizada.</li> <li>AWS Fargate: Motor de c\u00f3mputo sin servidor para contenedores que elimina la necesidad de administrar servidores.</li> <li>Amazon Elastic Container Registry (ECR): Repositorio para almacenar las im\u00e1genes Docker de la aplicaci\u00f3n.</li> <li>Amazon Virtual Private Cloud (VPC): Red virtual aislada donde se desplegar\u00e1n los recursos.</li> <li>Load Balancer: Para distribuir el tr\u00e1fico entrante entre las instancias de la aplicaci\u00f3n.</li> </ul>"},{"location":"despliegue/#pasos-para-el-despliegue","title":"Pasos para el Despliegue","text":""},{"location":"despliegue/#1-configuracion-del-entorno-aws","title":"1. Configuraci\u00f3n del Entorno AWS","text":"<ul> <li>Credenciales de AWS: Aseg\u00farese de tener una cuenta de AWS con las credenciales necesarias (Access Key ID y Secret Access Key).</li> <li>Configuraci\u00f3n del CLI de AWS: Instale y configure la AWS CLI en su entorno local o en el servidor de CI/CD.</li> </ul> <pre><code>aws configure\n</code></pre>"},{"location":"despliegue/#2-construccion-y-publicacion-de-la-imagen-docker","title":"2. Construcci\u00f3n y Publicaci\u00f3n de la Imagen Docker","text":"<ul> <li> <p>Construir la imagen Docker: <pre><code>docker build -t your_microservice:latest .\n</code></pre></p> </li> <li> <p>Crear un repositorio en ECR: <pre><code>aws ecr create-repository --repository-name your_microservice --region us-east-1\n</code></pre></p> </li> <li> <p>Autenticarse en ECR: <pre><code>$(aws ecr get-login --no-include-email --region us-east-1)\n</code></pre></p> </li> <li> <p>Etiquetar y subir la imagen a ECR: <pre><code>docker tag your_microservice:latest &lt;aws_account_id&gt;.dkr.ecr.us-east-1.amazonaws.com/your_microservice:latest\ndocker push &lt;aws_account_id&gt;.dkr.ecr.us-east-1.amazonaws.com/your_microservice:latest\n</code></pre></p> </li> </ul>"},{"location":"despliegue/#3-preparacion-de-la-plantilla-de-cloudformation","title":"3. Preparaci\u00f3n de la Plantilla de CloudFormation","text":"<p>Cree un archivo YAML llamado cloudformation-template.yaml que describa los recursos necesarios para el despliegue.</p> <p>Ejemplo de cloudformation-template.yaml <pre><code>AWSTemplateFormatVersion: '2010-09-09'\nDescription: Despliegue de YourMicroservice en AWS utilizando ECS y Fargate\n\nResources:\n  YourMicroserviceCluster:\n    Type: AWS::ECS::Cluster\n    Properties:\n      ClusterName: your-microservice-cluster\n\n  YourMicroserviceTaskDefinition:\n    Type: AWS::ECS::TaskDefinition\n    Properties:\n      Family: your-microservice-task\n      Cpu: '256'\n      Memory: '512'\n      NetworkMode: awsvpc\n      RequiresCompatibilities:\n        - FARGATE\n      ExecutionRoleArn: arn:aws:iam::&lt;aws_account_id&gt;:role/ecsTaskExecutionRole\n      ContainerDefinitions:\n        - Name: your-microservice-container\n          Image: &lt;aws_account_id&gt;.dkr.ecr.us-east-1.amazonaws.com/your_microservice:latest\n          PortMappings:\n            - ContainerPort: 8080\n              Protocol: tcp\n\n  YourMicroserviceService:\n    Type: AWS::ECS::Service\n    Properties:\n      Cluster: !Ref YourMicroserviceCluster\n      ServiceName: your-microservice-service\n      TaskDefinition: !Ref YourMicroserviceTaskDefinition\n      LaunchType: FARGATE\n      DesiredCount: 2\n      NetworkConfiguration:\n        AwsvpcConfiguration:\n          AssignPublicIp: ENABLED\n          Subnets:\n            - subnet-xxxxxxxx\n            - subnet-xxxxxxxx\n          SecurityGroups:\n            - sg-xxxxxxxx\n      LoadBalancers:\n        - ContainerName: your-microservice-container\n          ContainerPort: 8080\n          TargetGroupArn: !Ref YourMicroserviceTargetGroup\n\n  YourMicroserviceTargetGroup:\n    Type: AWS::ElasticLoadBalancingV2::TargetGroup\n    Properties:\n      Name: your-microservice-tg\n      Port: 8080\n      Protocol: HTTP\n      VpcId: vpc-xxxxxxxx\n      TargetType: ip\n      HealthCheckIntervalSeconds: 30\n      HealthCheckProtocol: HTTP\n      HealthCheckTimeoutSeconds: 5\n      HealthyThresholdCount: 5\n      UnhealthyThresholdCount: 2\n      Matcher:\n        HttpCode: '200'\n\n  YourMicroserviceLoadBalancer:\n    Type: AWS::ElasticLoadBalancingV2::LoadBalancer\n    Properties:\n      Name: your-microservice-lb\n      Subnets:\n        - subnet-xxxxxxxx\n        - subnet-xxxxxxxx\n      SecurityGroups:\n        - sg-xxxxxxxx\n      Scheme: internet-facing\n      Type: application\n\n  YourMicroserviceListener:\n    Type: AWS::ElasticLoadBalancingV2::Listener\n    Properties:\n      LoadBalancerArn: !Ref YourMicroserviceLoadBalancer\n      Port: 80\n      Protocol: HTTP\n      DefaultActions:\n        - Type: forward\n          TargetGroupArn: !Ref YourMicroserviceTargetGroup\n</code></pre></p> <p>Nota: Reemplace , subnet-xxxxxxxx, sg-xxxxxxxx, y vpc-xxxxxxxx con los valores correspondientes de su cuenta y entorno de AWS."},{"location":"despliegue/#4-despliegue-de-la-plantilla-con-cloudformation","title":"4. Despliegue de la Plantilla con CloudFormation","text":"<ul> <li>Crear el stack de CloudFormation: <pre><code>aws cloudformation create-stack --stack-name your-microservice-stack --template-body file://cloudformation-template.yaml --capabilities CAPABILITY_NAMED_IAM\n</code></pre></li> <li>Monitorear el estado del stack: <pre><code>aws cloudformation describe-stacks --stack-name your-microservice-stack\n</code></pre></li> <li>Actualizar el stack (si es necesario): <pre><code>aws cloudformation update-stack --stack-name your-microservice-stack --template-body file://cloudformation-template.yaml --capabilities CAPABILITY_NAMED_IAM\n</code></pre></li> </ul>"},{"location":"despliegue/#5-validacion-del-despliegue","title":"5. Validaci\u00f3n del Despliegue","text":"<ul> <li> <p>Obtener la URL del Load Balancer: <pre><code>aws cloudformation describe-stacks --stack-name your-microservice-stack --query \"Stacks[0].Outputs\"\n</code></pre></p> </li> <li> <p>Probar la aplicaci\u00f3n: Acceda a la URL obtenida en el paso anterior y verifique que la aplicaci\u00f3n est\u00e9 funcionando correctamente.</p> </li> </ul>"},{"location":"despliegue/#consideraciones-de-seguridad","title":"Consideraciones de Seguridad","text":"<ul> <li>Roles y Pol\u00edticas de IAM: Aseg\u00farese de que los roles utilizados tengan los permisos m\u00ednimos necesarios siguiendo el principio de privilegio m\u00ednimo.</li> <li>Almacenamiento de Credenciales: No almacene credenciales en el c\u00f3digo o en repositorios. Utilice AWS Secrets Manager o AWS Systems Manager Parameter Store para gestionar secretos de forma segura.</li> <li>Cifrado de Datos: Considere habilitar el cifrado en tr\u00e1nsito y en reposo donde sea aplicable.</li> </ul>"},{"location":"despliegue/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ul> <li>Infraestructura como C\u00f3digo (IaC): Mantenga las plantillas de CloudFormation y scripts de despliegue versionados junto con el c\u00f3digo de la aplicaci\u00f3n.</li> <li>Automatizaci\u00f3n de Despliegues: Integre el despliegue con su sistema de CI/CD para asegurar despliegues consistentes y reproducibles.</li> <li>Monitoreo y Logging: Configure Amazon CloudWatch para monitorear m\u00e9tricas y logs de la aplicaci\u00f3n y la infraestructura.</li> <li>Escalabilidad: Configure Auto Scaling en el servicio de ECS para ajustar autom\u00e1ticamente la capacidad en respuesta a la demanda.</li> <li>Gesti\u00f3n de Costos: Supervise el uso de recursos y optimice la configuraci\u00f3n para controlar costos.</li> </ul>"},{"location":"despliegue/#recursos-adicionales","title":"Recursos Adicionales","text":"<ul> <li>Documentaci\u00f3n de AWS CloudFormation</li> <li>Mejores Pr\u00e1cticas para AWS CloudFormation</li> <li>Despliegue de Contenedores en Amazon ECS</li> <li>AWS Fargate</li> </ul>"},{"location":"estructura/","title":"Estructura del Proyecto","text":"<p>Este documento describe detalladamente la estructura organizativa del proyecto, dise\u00f1ada para adherirse a los principios de la Arquitectura Limpia y facilitar el desarrollo de microservicios escalables y mantenibles en Python.</p>"},{"location":"estructura/#organizacion-de-directorios-y-archivos","title":"Organizaci\u00f3n de Directorios y Archivos","text":"<p>El proyecto est\u00e1 organizado en una jerarqu\u00eda de directorios que refleja las capas definidas por la Arquitectura Limpia. A continuaci\u00f3n se presenta la estructura general del proyecto:</p> <pre><code>your_microservice/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u2502   \u251c\u2500\u2500 entities/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 your_entity.py\n\u2502   \u2502   \u2514\u2500\u2500 repositories/\n\u2502   \u2502       \u2514\u2500\u2500 your_repository_interface.py\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u2502   \u2514\u2500\u2500 use_cases/\n\u2502   \u2502       \u2514\u2500\u2500 your_use_case.py\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2502   \u251c\u2500\u2500 repositories/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 your_repository_impl.py\n\u2502   \u2502   \u2514\u2500\u2500 services/\n\u2502   \u2502       \u2514\u2500\u2500 external_service.py\n\u2502   \u2514\u2500\u2500 presentation/\n\u2502       \u251c\u2500\u2500 controllers/\n\u2502       \u2502   \u2514\u2500\u2500 your_controller.py\n\u2502       \u2514\u2500\u2500 frameworks/\n\u2502           \u2514\u2500\u2500 flask_app.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 unit/\n\u2502   \u2514\u2500\u2500 integration/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 settings.py\n\u2502   \u2514\u2500\u2500 logging.conf\n\u251c\u2500\u2500 docs/\n\u2502   \u2514\u2500\u2500 arquitectura.md\n\u251c\u2500\u2500 requirements.txt\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 docker-compose.yml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"estructura/#descripcion-de-los-directorios-principales","title":"Descripci\u00f3n de los Directorios Principales","text":"<ul> <li> <p>app/: Contiene el c\u00f3digo fuente de la aplicaci\u00f3n, organizado en cuatro capas principales:</p> </li> <li> <p>domain/: Representa la capa de Dominio, incluyendo las entidades y las interfaces de repositorio que definen los contratos para la persistencia de datos.</p> <ul> <li>entities/: Define las clases de entidad que encapsulan las reglas de negocio fundamentales.</li> <li>repositories/: Contiene las interfaces que declaran los m\u00e9todos para operaciones de datos sin implementar detalles t\u00e9cnicos.</li> </ul> </li> <li> <p>application/: Corresponde a la capa de Aplicaci\u00f3n, donde se implementan los casos de uso o servicios de aplicaci\u00f3n.</p> <ul> <li>use_cases/: Implementa la l\u00f3gica de negocio espec\u00edfica, orquestando la interacci\u00f3n entre el dominio y la infraestructura.</li> </ul> </li> <li> <p>infrastructure/: Representa la capa de Infraestructura, proporcionando implementaciones concretas para las interfaces definidas en el dominio.</p> <ul> <li>repositories/: Implementaciones de repositorios que interact\u00faan con bases de datos u otros sistemas de almacenamiento.</li> <li>services/: Integraciones con servicios externos, como APIs de terceros o colas de mensajes.</li> </ul> </li> <li> <p>presentation/: Corresponde a la capa de Presentaci\u00f3n, manejando la interacci\u00f3n con el mundo exterior a trav\u00e9s de controladores y frameworks.</p> <ul> <li>controllers/: Define los controladores que gestionan las solicitudes entrantes y las respuestas salientes.</li> <li>frameworks/: Contiene la configuraci\u00f3n y el arranque de frameworks web, como Flask o FastAPI.</li> </ul> </li> <li> <p>tests/: Incluye las pruebas automatizadas del proyecto para garantizar la calidad y el correcto funcionamiento del c\u00f3digo.</p> </li> <li> <p>unit/: Pruebas unitarias que validan componentes individuales de forma aislada.</p> </li> <li> <p>integration/: Pruebas de integraci\u00f3n que verifican la interacci\u00f3n entre diferentes componentes o sistemas externos.</p> </li> <li> <p>config/: Almacena archivos de configuraci\u00f3n globales.</p> </li> <li> <p>settings.py: Configuraciones generales de la aplicaci\u00f3n, como variables de entorno y par\u00e1metros de inicializaci\u00f3n.</p> </li> <li> <p>logging.conf: Configuraci\u00f3n del sistema de logging para el monitoreo y depuraci\u00f3n.</p> </li> <li> <p>docs/: Contiene la documentaci\u00f3n del proyecto, incluyendo diagramas, manuales de uso y especificaciones t\u00e9cnicas.</p> </li> <li> <p>requirements.txt: Lista las dependencias y paquetes necesarios para ejecutar la aplicaci\u00f3n, facilitando la instalaci\u00f3n y configuraci\u00f3n del entorno.</p> </li> <li> <p>Dockerfile: Archivo con instrucciones para construir la imagen Docker de la aplicaci\u00f3n, facilitando su despliegue en entornos aislados.</p> </li> <li> <p>docker-compose.yml: Permite la orquestaci\u00f3n de m\u00faltiples contenedores Docker, \u00fatil para levantar servicios adicionales como bases de datos durante el desarrollo o pruebas.</p> </li> <li> <p>README.md: Proporciona una descripci\u00f3n general del proyecto, instrucciones de instalaci\u00f3n y gu\u00edas r\u00e1pidas de uso.</p> </li> </ul>"},{"location":"estructura/#principios-de-organizacion","title":"Principios de Organizaci\u00f3n","text":"<p>La estructura propuesta se basa en los siguientes principios fundamentales:</p> <ol> <li> <p>Separaci\u00f3n de Responsabilidades: Cada capa tiene una funci\u00f3n espec\u00edfica, reduciendo el acoplamiento y mejorando la cohesi\u00f3n del c\u00f3digo.</p> </li> <li> <p>Independencia de Frameworks: El n\u00facleo de la aplicaci\u00f3n es independiente de frameworks y librer\u00edas externas, lo que facilita su mantenimiento y escalabilidad.</p> </li> <li> <p>Inversi\u00f3n de Dependencias: Las capas internas no dependen de las externas; las dependencias siempre apuntan hacia el n\u00facleo de la aplicaci\u00f3n.</p> </li> <li> <p>Facilidad de Pruebas: La modularidad y la clara separaci\u00f3n facilitan la implementaci\u00f3n de pruebas unitarias y de integraci\u00f3n.</p> </li> </ol>"},{"location":"estructura/#detalles-especificos","title":"Detalles Espec\u00edficos","text":""},{"location":"estructura/#capa-de-dominio","title":"Capa de Dominio","text":"<p>Contiene las entidades y las interfaces que representan los conceptos centrales del negocio. Es independiente de detalles de implementaci\u00f3n y frameworks.</p>"},{"location":"estructura/#capa-de-aplicacion","title":"Capa de Aplicaci\u00f3n","text":"<p>Implementa los casos de uso que coordinan las acciones entre el dominio y la infraestructura. Act\u00faa como un orquestador que utiliza las entidades y repositorios para ejecutar la l\u00f3gica de negocio.</p>"},{"location":"estructura/#capa-de-infraestructura","title":"Capa de Infraestructura","text":"<p>Proporciona las implementaciones concretas de las interfaces definidas en el dominio. Maneja detalles t\u00e9cnicos como la persistencia de datos, comunicaci\u00f3n con servicios externos y otros recursos de infraestructura.</p>"},{"location":"estructura/#capa-de-presentacion","title":"Capa de Presentaci\u00f3n","text":"<p>Gestiona la interacci\u00f3n con el usuario o cliente. Incluye controladores y configuraciones de frameworks que exponen la funcionalidad de la aplicaci\u00f3n a trav\u00e9s de APIs u otras interfaces.</p>"},{"location":"estructura/#beneficios-de-la-estructura-propuesta","title":"Beneficios de la Estructura Propuesta","text":"<ul> <li>Escalabilidad: Facilita la adici\u00f3n de nuevas funcionalidades sin afectar las existentes.</li> <li>Mantenibilidad: Simplifica el mantenimiento y actualizaci\u00f3n del c\u00f3digo gracias a su organizaci\u00f3n modular.</li> <li>Flexibilidad: Permite cambiar detalles de infraestructura o frameworks sin impactar el n\u00facleo de la aplicaci\u00f3n.</li> <li>Reutilizaci\u00f3n: Promueve la reutilizaci\u00f3n de componentes y l\u00f3gica de negocio en diferentes partes de la aplicaci\u00f3n o en otros proyectos.</li> </ul>"},{"location":"estructura/#recomendaciones","title":"Recomendaciones","text":"<ul> <li>Consistencia en la Codificaci\u00f3n: Utilizar convenciones de c\u00f3digo y estilo consistentes para mejorar la legibilidad y facilitar la colaboraci\u00f3n.</li> <li>Documentaci\u00f3n Continua: Mantener actualizada la documentaci\u00f3n en el directorio <code>docs/</code> para reflejar cambios y decisiones arquitect\u00f3nicas.</li> <li>Gesti\u00f3n de Dependencias: Actualizar y revisar peri\u00f3dicamente <code>requirements.txt</code> para garantizar la seguridad y compatibilidad de las dependencias.</li> </ul>"},{"location":"estructura/#proximos-pasos","title":"Pr\u00f3ximos Pasos","text":"<p>Para profundizar en la implementaci\u00f3n de cada capa y entender c\u00f3mo interact\u00faan entre s\u00ed, consulte la secci\u00f3n Capas. Se proporcionan detalles y ejemplos espec\u00edficos para guiar el desarrollo y personalizaci\u00f3n del microservicio.</p>"},{"location":"intro/","title":"Introducci\u00f3n","text":"<p>La Arquitectura Limpia es un enfoque de dise\u00f1o de software propuesto por Robert C. Martin, tambi\u00e9n conocido como \"Uncle Bob\". Este paradigma busca crear sistemas que sean:</p> <ul> <li>Independientes de frameworks y librer\u00edas: La arquitectura del software no est\u00e1 acoplada a herramientas o tecnolog\u00edas espec\u00edficas, lo que permite cambiar o actualizar componentes sin afectar el n\u00facleo del sistema.</li> <li>Testeables: La separaci\u00f3n de responsabilidades facilita la implementaci\u00f3n de pruebas automatizadas en todos los niveles, mejorando la calidad y confiabilidad del software.</li> <li>Independientes de la interfaz de usuario: La l\u00f3gica de negocio est\u00e1 aislada de las preocupaciones de presentaci\u00f3n, permitiendo modificar o reemplazar la interfaz sin impactar las reglas de negocio.</li> <li>Independientes de la base de datos: Las operaciones de persistencia est\u00e1n abstra\u00eddas, lo que permite cambiar de tecnolog\u00eda de almacenamiento sin alterar la l\u00f3gica fundamental.</li> <li>Independientes de agentes externos: El sistema es resiliente a cambios en servicios externos o integraciones de terceros.</li> </ul> <p>Este proyecto proporciona un scaffolding para desarrollar microservicios en Python aplicando los principios de la Arquitectura Limpia. Al adoptar esta estructura, los desarrolladores pueden:</p> <ul> <li>Enfocarse en la l\u00f3gica de negocio: Al aislar las reglas y procesos centrales, se facilita su desarrollo y evoluci\u00f3n.</li> <li>Mejorar la mantenibilidad y escalabilidad: Una arquitectura bien definida reduce la complejidad y permite que el sistema crezca de manera ordenada.</li> <li>Facilitar la colaboraci\u00f3n: La clara separaci\u00f3n de responsabilidades y contratos definidos entre capas promueve un trabajo en equipo m\u00e1s efectivo.</li> </ul>"},{"location":"intro/#objetivos-de-esta-introduccion","title":"Objetivos de esta Introducci\u00f3n","text":"<ul> <li>Presentar los conceptos fundamentales de la Arquitectura Limpia y su relevancia en el desarrollo moderno de software.</li> <li>Destacar los beneficios de aplicar esta arquitectura en microservicios construidos con Python.</li> <li>Proporcionar una visi\u00f3n general de c\u00f3mo est\u00e1 estructurado este scaffolding y c\u00f3mo puede ser utilizado como base para proyectos futuros.</li> </ul> <p>La comprensi\u00f3n profunda de estos conceptos es esencial para aprovechar al m\u00e1ximo las ventajas que ofrece esta arquitectura. Se recomienda continuar con la lectura de la Estructura del Proyecto para familiarizarse con la organizaci\u00f3n y componentes espec\u00edficos de este scaffolding.</p>"},{"location":"pruebas/","title":"Pruebas","text":"<p>Las pruebas son un componente esencial en el desarrollo de software de alta calidad. Garantizan que la aplicaci\u00f3n funcione seg\u00fan lo esperado, facilitando la detecci\u00f3n temprana de errores y mejorando la confiabilidad y mantenibilidad del sistema. Este proyecto incorpora una estrategia de pruebas integral que incluye pruebas unitarias y de integraci\u00f3n.</p>"},{"location":"pruebas/#organizacion-de-las-pruebas","title":"Organizaci\u00f3n de las Pruebas","text":"<p>El c\u00f3digo de las pruebas se encuentra organizado en el directorio <code>tests/</code>, siguiendo una estructura que refleja la organizaci\u00f3n de la aplicaci\u00f3n:</p> <pre><code>tests/\n\u251c\u2500\u2500 unit/\n\u2502   \u251c\u2500\u2500 domain/\n\u2502   \u251c\u2500\u2500 application/\n\u2502   \u251c\u2500\u2500 infrastructure/\n\u2502   \u2514\u2500\u2500 presentation/\n\u2514\u2500\u2500 integration/\n    \u251c\u2500\u2500 repositories/\n    \u2514\u2500\u2500 services/\n</code></pre>"},{"location":"pruebas/#pruebas-unitarias","title":"Pruebas Unitarias","text":"<p>Las pruebas unitarias validan el funcionamiento correcto de componentes individuales en aislamiento, como funciones, m\u00e9todos o clases, sin depender de componentes externos o sistemas. Estas pruebas se ubican en el directorio tests/unit/ y est\u00e1n organizadas por capas para reflejar la estructura de la aplicaci\u00f3n.</p>"},{"location":"pruebas/#herramientas-utilizadas","title":"Herramientas Utilizadas","text":"<ul> <li>Pytest: Un marco de pruebas potente y flexible que simplifica la escritura de pruebas unitarias.</li> <li>Unittest:: El m\u00f3dulo est\u00e1ndar de Python para pruebas unitarias, utilizado en casos donde se requiera compatibilidad con herramientas existentes.</li> </ul>"},{"location":"pruebas/#ejemplo-de-prueba-unitaria","title":"Ejemplo de Prueba Unitaria","text":""},{"location":"pruebas/#testsunitdomainentitiestest_your_entitypy","title":"tests/unit/domain/entities/test_your_entity.py","text":"<pre><code>import pytest\nfrom app.domain.entities.your_entity import YourEntity\n\ndef test_your_entity_initialization():\n    entity = YourEntity(attribute1='value1', attribute2='value2')\n    assert entity.attribute1 == 'value1'\n    assert entity.attribute2 == 'value2'\n\ndef test_your_entity_validation():\n    with pytest.raises(ValueError):\n        YourEntity(attribute1=None, attribute2='value2')\n</code></pre>"},{"location":"pruebas/#pruebas-de-integracion","title":"Pruebas de Integraci\u00f3n","text":"<p>Las pruebas de integraci\u00f3n verifican la interacci\u00f3n entre diferentes componentes del sistema, asegurando que funcionen correctamente en conjunto. Estas pruebas pueden involucrar bases de datos, servicios externos o m\u00f3dulos de infraestructura.</p>"},{"location":"pruebas/#herramientas-utilizadas_1","title":"Herramientas Utilizadas","text":"<ul> <li>Pytest: Tambi\u00e9n utilizado para pruebas de integraci\u00f3n por su capacidad para manejar fixtures y configuraciones complejas.</li> <li>Docker Compose:: Para levantar servicios dependientes como bases de datos durante las pruebas.</li> </ul>"},{"location":"pruebas/#ejemplo-de-prueba-de-integracion","title":"Ejemplo de Prueba de Integraci\u00f3n","text":""},{"location":"pruebas/#testsintegrationrepositoriestest_your_repository_implpy","title":"tests/integration/repositories/test_your_repository_impl.py","text":"<pre><code>import pytest\nfrom app.infrastructure.repositories.your_repository_impl import YourRepositoryImpl\nfrom app.domain.entities.your_entity import YourEntity\nfrom config.settings import settings\n\n@pytest.fixture\ndef repository():\n    # Configuraci\u00f3n de la conexi\u00f3n a la base de datos de prueba\n    db_connection = setup_test_db_connection()\n    return YourRepositoryImpl(db_connection)\n\ndef test_repository_save_and_get(repository):\n    entity = YourEntity(attribute1='value1', attribute2='value2')\n    repository.save(entity)\n    retrieved_entity = repository.get_by_id(entity.id)\n    assert retrieved_entity == entity\n</code></pre>"},{"location":"pruebas/#cobertura-de-pruebas","title":"Cobertura de Pruebas","text":"<p>Es recomendable medir la cobertura de las pruebas para identificar \u00e1reas del c\u00f3digo que no est\u00e1n siendo verificadas. Herramientas como Coverage.py pueden integrarse con Pytest para generar reportes detallados.</p>"},{"location":"pruebas/#generacion-de-reporte-de-cobertura","title":"Generaci\u00f3n de Reporte de Cobertura","text":"<pre><code>pytest --cov=app tests/\n</code></pre>"},{"location":"pruebas/#ejecucion-de-las-pruebas","title":"Ejecuci\u00f3n de las Pruebas","text":"<p>Para ejecutar todas las pruebas, utilice el siguiente comando en la ra\u00edz del proyecto:</p> <pre><code>pytest tests/\n</code></pre> <p>Puede especificar directorios o archivos espec\u00edficos:</p> <ul> <li> <p>Ejecutar solo pruebas unitarias: <pre><code>pytest tests/unit/\n</code></pre></p> </li> <li> <p>Ejecutar solo pruebas de integraci\u00f3n:: <pre><code>pytest tests/integration/\n</code></pre></p> </li> </ul>"},{"location":"pruebas/#buenas-practicas","title":"Buenas Pr\u00e1cticas","text":"<ul> <li>Escribir Pruebas Primero (TDD): Considerar la adopci\u00f3n del Desarrollo Dirigido por Pruebas para mejorar la calidad y dise\u00f1o del c\u00f3digo.</li> <li>Pruebas Aisladas: Asegurarse de que las pruebas unitarias no dependan del estado de otras pruebas o de componentes externos.</li> <li>Nombres Descriptivos: Utilizar nombres claros y descriptivos para las funciones de prueba, facilitando la comprensi\u00f3n del prop\u00f3sito de cada una.</li> <li>Uso de Fixtures: Emplear fixtures para configurar y limpiar el entorno de pruebas de manera eficiente.</li> </ul>"},{"location":"pruebas/#integracion-continua","title":"Integraci\u00f3n Continua","text":"<p>Integrar las pruebas en el pipeline de Integraci\u00f3n Continua (CI) es fundamental para detectar problemas de manera temprana. Configure el sistema CI para ejecutar las pruebas en cada commit o pull request.</p>"},{"location":"pruebas/#recomendaciones-adicionales","title":"Recomendaciones Adicionales","text":"<ul> <li>Mocking: Utilizar t\u00e9cnicas de mocking para simular componentes externos y aislar el c\u00f3digo bajo prueba.</li> <li>Pruebas de Regresi\u00f3n: Mantener y actualizar las pruebas al realizar cambios en el c\u00f3digo para prevenir la reintroducci\u00f3n de errores.</li> <li>Documentaci\u00f3n de Pruebas: Documentar casos de prueba complejos y escenarios especiales para facilitar el mantenimiento y colaboraci\u00f3n.</li> </ul>"},{"location":"capas/aplicacion/","title":"Capa de Aplicaci\u00f3n","text":"<p>La Capa de Aplicaci\u00f3n act\u00faa como orquestadora de los casos de uso y coordina la interacci\u00f3n entre la capa de dominio y las dem\u00e1s capas del sistema. Su principal objetivo es implementar la l\u00f3gica espec\u00edfica de la aplicaci\u00f3n sin incorporar detalles de infraestructura o presentaci\u00f3n.</p>"},{"location":"capas/aplicacion/#responsabilidades","title":"Responsabilidades","text":"<ul> <li> <p>Casos de Uso (Use Cases): Representan secuencias de acciones que la aplicaci\u00f3n puede realizar, encapsulando la l\u00f3gica de procesos y flujos de trabajo.</p> </li> <li> <p>Coordinaci\u00f3n de Entidades y Repositorios: Gestiona c\u00f3mo las entidades del dominio interact\u00faan con los repositorios y otros servicios necesarios.</p> </li> <li> <p>Validaciones y Reglas de Aplicaci\u00f3n: Implementa reglas que son propias de la aplicaci\u00f3n pero que no pertenecen al dominio puro.</p> </li> </ul>"},{"location":"capas/aplicacion/#principios-clave","title":"Principios Clave","text":"<ul> <li> <p>Independencia de Infraestructura: No debe contener c\u00f3digo relacionado con bases de datos, redes u otros sistemas externos.</p> </li> <li> <p>Orientada a Casos de Uso: Cada caso de uso representa una funcionalidad espec\u00edfica y completa desde el punto de vista del usuario o sistema.</p> </li> <li> <p>Facilidad de Testeo: Al mantenerse aislada de detalles externos, facilita la creaci\u00f3n de pruebas unitarias para validar la l\u00f3gica de aplicaci\u00f3n.</p> </li> </ul>"},{"location":"capas/aplicacion/#estructura-de-directorios","title":"Estructura de Directorios","text":"<pre><code>app/\n\u251c\u2500\u2500 application/\n    \u2514\u2500\u2500 use_cases/\n        \u2514\u2500\u2500 your_use_case.py\n</code></pre>"},{"location":"capas/aplicacion/#ejemplo","title":"Ejemplo","text":""},{"location":"capas/aplicacion/#caso-de-uso","title":"Caso de Uso","text":""},{"location":"capas/aplicacion/#your_use_casepy","title":"your_use_case.py","text":"<pre><code>class YourUseCase:\n    def __init__(self, repository):\n        self.repository = repository\n\n    def execute(self, input_data):\n        # Validaciones de entrada\n        if not input_data:\n            raise ValueError(\"Los datos de entrada son obligatorios\")\n\n        # Interacci\u00f3n con el dominio\n        entity = self.repository.get_by_id(input_data['id'])\n        if not entity:\n            raise EntityNotFoundException(\"Entidad no encontrada\")\n\n        # L\u00f3gica de aplicaci\u00f3n\n        entity.process()\n        self.repository.save(entity)\n\n        # Retornar resultado o estado\n        return entity\n</code></pre>"},{"location":"capas/aplicacion/#beneficios","title":"Beneficios","text":"<ul> <li> <p>Claridad en la L\u00f3gica de Negocio: Al separar los casos de uso, se facilita la comprensi\u00f3n y mantenimiento de la funcionalidad de la aplicaci\u00f3n.</p> </li> <li> <p>Reutilizaci\u00f3n: Los casos de uso pueden ser utilizados por diferentes interfaces de usuario o sistemas externos sin duplicar c\u00f3digo.</p> </li> <li> <p>Flexibilidad: Permite modificar flujos de trabajo sin afectar las capas de dominio o infraestructura.</p> </li> </ul>"},{"location":"capas/aplicacion/#capas","title":"Capas","text":"<ul> <li>Dominio</li> <li>Aplicaci\u00f3n</li> <li>Infraestructura</li> <li>Presentaci\u00f3n</li> </ul>"},{"location":"capas/dominio/","title":"Capa de Dominio","text":"<p>La Capa de Dominio es el n\u00facleo central de la arquitectura y representa las reglas de negocio y las entidades fundamentales del sistema. Esta capa es completamente independiente de detalles de implementaci\u00f3n externos, como frameworks, bases de datos o interfaces de usuario, lo que garantiza que los cambios en esas \u00e1reas no afecten la l\u00f3gica esencial de la aplicaci\u00f3n.</p>"},{"location":"capas/dominio/#responsabilidades","title":"Responsabilidades","text":"<ul> <li> <p>Entidades (Entities): Son objetos del dominio que encapsulan atributos y comportamientos coherentes con las reglas de negocio. Representan conceptos clave del sistema, como usuarios, productos o transacciones.</p> </li> <li> <p>Interfaces de Repositorio: Definen contratos para la persistencia y recuperaci\u00f3n de entidades sin especificar detalles t\u00e9cnicos. Estas interfaces permiten que la capa de aplicaci\u00f3n interact\u00fae con los datos de manera abstracta.</p> </li> <li> <p>Reglas de Negocio: Contienen la l\u00f3gica y validaciones que son intr\u00ednsecas al dominio, asegurando la integridad y consistencia de los datos y procesos.</p> </li> </ul>"},{"location":"capas/dominio/#principios-clave","title":"Principios Clave","text":"<ul> <li> <p>Independencia Tecnol\u00f3gica: La capa de dominio no depende de ninguna tecnolog\u00eda externa, lo que facilita su reutilizaci\u00f3n y portabilidad.</p> </li> <li> <p>Modelo Rico: Las entidades no son simples estructuras de datos; pueden contener l\u00f3gica relevante que garantiza que siempre se encuentren en un estado v\u00e1lido.</p> </li> <li> <p>Abstracci\u00f3n: Las interfaces permiten definir contratos claros sin exponer detalles de implementaci\u00f3n, promoviendo la inversi\u00f3n de dependencias.</p> </li> </ul>"},{"location":"capas/dominio/#estructura-de-directorios","title":"Estructura de Directorios","text":"<pre><code>app/\n\u251c\u2500\u2500 domain/\n    \u251c\u2500\u2500 entities/\n    \u2502   \u2514\u2500\u2500 your_entity.py\n    \u2514\u2500\u2500 repositories/\n        \u2514\u2500\u2500 your_repository_interface.py\n</code></pre>"},{"location":"capas/dominio/#ejemplo","title":"Ejemplo","text":""},{"location":"capas/dominio/#entidad","title":"Entidad","text":""},{"location":"capas/dominio/#your_entitypy","title":"your_entity.py","text":"<pre><code>class YourEntity:\n    def __init__(self, attribute1, attribute2):\n        self.attribute1 = attribute1\n        self.attribute2 = attribute2\n        self.validate()\n\n    def validate(self):\n        if not self.attribute1:\n            raise ValueError(\"attribute1 es obligatorio\")\n        # Otras validaciones y l\u00f3gica de negocio\n</code></pre>"},{"location":"capas/dominio/#interfaz-de-repositorio","title":"Interfaz de Repositorio","text":""},{"location":"capas/dominio/#your_repository_interfacepy","title":"your_repository_interface.py","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass YourRepositoryInterface(ABC):\n    @abstractmethod\n    def get_by_id(self, entity_id):\n        pass\n\n    @abstractmethod\n    def save(self, entity):\n        pass\n</code></pre>"},{"location":"capas/dominio/#beneficios","title":"Beneficios","text":"<ul> <li> <p>Testabilidad Mejorada: Al no depender de componentes externos, las pruebas unitarias pueden centrarse en la l\u00f3gica de negocio pura.</p> </li> <li> <p>Mantenibilidad: Los cambios en tecnolog\u00edas o frameworks no afectan esta capa, reduciendo el impacto de modificaciones.</p> </li> <li> <p>Claridad Conceptual: Facilita la comprensi\u00f3n del dominio del problema al estar aislado y bien definido.</p> </li> </ul>"},{"location":"capas/dominio/#capas","title":"Capas","text":"<ul> <li>Dominio</li> <li>Aplicaci\u00f3n</li> <li>Infraestructura</li> <li>Presentaci\u00f3n</li> </ul>"},{"location":"capas/infraestructura/","title":"Capa de Infraestructura","text":"<p>La Capa de Infraestructura proporciona implementaciones concretas para las interfaces definidas en las capas superiores, manejando detalles t\u00e9cnicos y de comunicaci\u00f3n con sistemas externos. Esta capa es donde se integra la aplicaci\u00f3n con tecnolog\u00edas espec\u00edficas, como bases de datos, servicios web, sistemas de mensajer\u00eda, entre otros.</p>"},{"location":"capas/infraestructura/#responsabilidades","title":"Responsabilidades","text":"<ul> <li> <p>Implementaci\u00f3n de Repositorios: Provee las clases que interact\u00faan directamente con los sistemas de persistencia, cumpliendo con los contratos definidos en las interfaces del dominio.</p> </li> <li> <p>Servicios Externos: Maneja la comunicaci\u00f3n con APIs externas, colas de mensajes y otros servicios fuera del control de la aplicaci\u00f3n.</p> </li> <li> <p>Gesti\u00f3n de Recursos T\u00e9cnicos: Configura y administra conexiones, sesiones y otros recursos necesarios para la infraestructura.</p> </li> </ul>"},{"location":"capas/infraestructura/#principios-clave","title":"Principios Clave","text":"<ul> <li> <p>Cumplimiento de Contratos: Las clases de esta capa deben adherirse estrictamente a las interfaces y contratos definidos en el dominio y la aplicaci\u00f3n.</p> </li> <li> <p>Aislamiento de Detalles T\u00e9cnicos: Los detalles de implementaci\u00f3n deben estar contenidos en esta capa, evitando que las capas superiores dependan de tecnolog\u00edas espec\u00edficas.</p> </li> <li> <p>Facilidad de Sustituci\u00f3n: Al implementar interfaces, es posible reemplazar componentes de infraestructura sin afectar el resto del sistema (por ejemplo, cambiar de una base de datos SQL a NoSQL).</p> </li> </ul>"},{"location":"capas/infraestructura/#estructura-de-directorios","title":"Estructura de Directorios","text":"<pre><code>app/\n\u251c\u2500\u2500 infrastructure/\n    \u251c\u2500\u2500 repositories/\n    \u2502   \u2514\u2500\u2500 your_repository_impl.py\n    \u2514\u2500\u2500 services/\n        \u2514\u2500\u2500 external_service.py\n</code></pre>"},{"location":"capas/infraestructura/#ejemplo","title":"Ejemplo","text":""},{"location":"capas/infraestructura/#your_repository_implpy","title":"your_repository_impl.py","text":"<pre><code>from app.domain.repositories.your_repository_interface import YourRepositoryInterface\n\nclass YourRepositoryImpl(YourRepositoryInterface):\n    def __init__(self, db_connection):\n        self.db_connection = db_connection\n\n    def get_by_id(self, entity_id):\n        # Implementaci\u00f3n espec\u00edfica utilizando la base de datos\n        result = self.db_connection.query(\"SELECT * FROM entities WHERE id = ?\", (entity_id,))\n        if result:\n            return YourEntity(**result[0])\n        return None\n\n    def save(self, entity):\n        # Implementaci\u00f3n espec\u00edfica para guardar la entidad\n        self.db_connection.execute(\"INSERT INTO entities (...) VALUES (...)\", entity.to_dict())\n</code></pre>"},{"location":"capas/infraestructura/#servicio-externo","title":"Servicio Externo","text":""},{"location":"capas/infraestructura/#external_servicepy","title":"external_service.py","text":"<pre><code>class ExternalService:\n    def __init__(self, api_client):\n        self.api_client = api_client\n\n    def send_data(self, data):\n        response = self.api_client.post(\"/external-endpoint\", json=data)\n        return response.status_code == 200\n</code></pre>"},{"location":"capas/infraestructura/#beneficios","title":"Beneficios","text":"<ul> <li> <p>Modularidad: Facilita la gesti\u00f3n y organizaci\u00f3n de componentes relacionados con la infraestructura.</p> </li> <li> <p>Flexibilidad Tecnol\u00f3gica: Permite cambiar o actualizar tecnolog\u00edas subyacentes sin modificar las capas de dominio o aplicaci\u00f3n.</p> </li> <li> <p>Responsabilidad Clara: Centraliza el manejo de detalles t\u00e9cnicos, lo que simplifica el mantenimiento y la resoluci\u00f3n de problemas.</p> </li> </ul>"},{"location":"capas/infraestructura/#capas","title":"Capas","text":"<ul> <li>Dominio</li> <li>Aplicaci\u00f3n</li> <li>Infraestructura</li> <li>Presentaci\u00f3n</li> </ul>"},{"location":"capas/presentacion/","title":"Capa de Presentaci\u00f3n","text":"<p>La Capa de Presentaci\u00f3n es la responsable de gestionar la interacci\u00f3n entre el usuario o cliente y la aplicaci\u00f3n. Esta capa expone la funcionalidad del sistema a trav\u00e9s de interfaces como APIs RESTful, interfaces gr\u00e1ficas de usuario (GUIs) o interfaces de l\u00ednea de comandos (CLIs).</p>"},{"location":"capas/presentacion/#responsabilidades","title":"Responsabilidades","text":"<ul> <li> <p>Controladores: Manejan las solicitudes entrantes, coordinan la ejecuci\u00f3n de los casos de uso y preparan las respuestas adecuadas.</p> </li> <li> <p>Configuraci\u00f3n de Frameworks: Inicializa y configura los frameworks utilizados para gestionar las interfaces de usuario o protocolos de comunicaci\u00f3n.</p> </li> <li> <p>Validaci\u00f3n y Formateo: Realiza validaciones de datos de entrada y formatea las respuestas seg\u00fan sea necesario (por ejemplo, JSON).</p> </li> </ul>"},{"location":"capas/presentacion/#principios-clave","title":"Principios Clave","text":"<ul> <li> <p>Dependencia en la Capa de Aplicaci\u00f3n: Los controladores utilizan los casos de uso definidos en la capa de aplicaci\u00f3n para ejecutar la l\u00f3gica de negocio.</p> </li> <li> <p>Aislamiento de la L\u00f3gica de Negocio: No deben contener l\u00f3gica de negocio; su funci\u00f3n es coordinar y delegar.</p> </li> <li> <p>Adaptabilidad: Permite cambiar o agregar nuevas interfaces de usuario sin modificar las capas internas de la aplicaci\u00f3n.</p> </li> </ul>"},{"location":"capas/presentacion/#estructura-de-directorios","title":"Estructura de Directorios","text":"<pre><code>app/\n\u251c\u2500\u2500 presentation/\n    \u251c\u2500\u2500 controllers/\n    \u2502   \u2514\u2500\u2500 your_controller.py\n    \u2514\u2500\u2500 frameworks/\n        \u2514\u2500\u2500 flask_app.py\n</code></pre>"},{"location":"capas/presentacion/#ejemplos","title":"Ejemplos","text":""},{"location":"capas/presentacion/#controlador","title":"Controlador","text":""},{"location":"capas/presentacion/#your_controllerpy","title":"your_controller.py","text":"<pre><code>from app.application.use_cases.your_use_case import YourUseCase\nfrom app.infrastructure.repositories.your_repository_impl import YourRepositoryImpl\n\nclass YourController:\n    def __init__(self):\n        repository = YourRepositoryImpl(db_connection)\n        self.use_case = YourUseCase(repository)\n\n    def handle_request(self, request_data):\n        # Validaci\u00f3n de datos de entrada\n        input_data = self.validate_request(request_data)\n        # Ejecuci\u00f3n del caso de uso\n        result = self.use_case.execute(input_data)\n        # Preparaci\u00f3n de la respuesta\n        response = self.format_response(result)\n        return response\n\n    def validate_request(self, request_data):\n        # Implementar validaciones necesarias\n        pass\n\n    def format_response(self, result):\n        # Formatear el resultado para la respuesta\n        pass\n</code></pre>"},{"location":"capas/presentacion/#configuracion-del-framework","title":"Configuraci\u00f3n del Framework","text":""},{"location":"capas/presentacion/#flask_apppy","title":"flask_app.py","text":"<pre><code>from flask import Flask, request, jsonify\nfrom app.presentation.controllers.your_controller import YourController\n\napp = Flask(__name__)\ncontroller = YourController()\n\n@app.route('/endpoint', methods=['POST'])\ndef endpoint():\n    request_data = request.get_json()\n    response = controller.handle_request(request_data)\n    return jsonify(response), 200\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n</code></pre>"},{"location":"capas/presentacion/#beneficios","title":"Beneficios","text":"<ul> <li> <p>Interfaz Consistente: Proporciona una interfaz uniforme para que los clientes interact\u00faen con la aplicaci\u00f3n.</p> </li> <li> <p>Separaci\u00f3n de Preocupaciones: A\u00edsla las responsabilidades de presentaci\u00f3n y protocolo de comunicaci\u00f3n de la l\u00f3gica de negocio.</p> </li> <li> <p>Escalabilidad: Facilita la adici\u00f3n de nuevos puntos de entrada o la adaptaci\u00f3n a nuevos canales de comunicaci\u00f3n.</p> </li> </ul>"},{"location":"capas/presentacion/#capas","title":"Capas","text":"<ul> <li>Dominio</li> <li>Aplicaci\u00f3n</li> <li>Infraestructura</li> <li>Presentaci\u00f3n</li> </ul>"}]}